# C# 기초

## 형식, 변수 및 값
- C#은 강력한 형식 언어
- 모든 변수 및 상수에는 값으로 계산되는 모든식을 실행하는 형식을 가진다.
- 모든 메서드 선언은 각 입력 매개 변수와 반환값에 대해 이름, 매개 변수 수, 형식 및 종류(값, 참조 또는 출력)를 지정한다.
- 형식에 저장되는 정보
    * 형식 변수에 필요한 스토리지 공간
    * 형식이 나타낼 수 있는 최대값 및 최소값
    * 형식에 포함되는 멤버(메서드, 필드, 이벤트등)
    * 형식이 상속하는 기본 형식
    * 구현하는 인터페이스
    * 런타임에 변수에 대한 메모리가 할당될 위치
    * 혀용되는 작업 유형
- 컴파일러는 형식 정보를 실행 파일에 메타데이터로 포함, CLR(공용 언어 런타임)은 런타임에 이 메타데이터를 사용하여 메모리를 할탕 및 회수 시 형식 안정성을 추가로 보장

</br>
</br>

## CTS(공용 형식 시스템)
```
System.Object
|
|-- System.Value
|   |
|   |-- System.Enum
|   |   |-- All enums
|   |------ System.Int32(include built-in numberic type)
|   |------ System.Boolean
|   |------ User-defined structs(All structs)
|   |------ Etc.
|   |------ ...
|
|-- All Base Class, Library classes and interfaces, inluding:
|-- System.String
|-- System.Array
|-- User-defined classes and interfaces
|-- Etc.
...
```
- 형식 시스템은 상속 원칙을 지원하고, 기본 형식에서 다른 형식으로 파생된다.
- 파생 형식은 기본형식의 메서드/속성/기타 멤버를 상속하는, 상속 계층의 기본 두 형식의 멤버를 상속한다.
- 모든 형식은 기본 형식(System.Object)에서 파생된다.
- 이 통합 형식 계층 구조를 CTS(공용 형식 시스템)이라 한다.
- CTS의 기본 두 형식은 값 형식과 참조 형식으로 나누어 진다.
- 값 형식은 모든 기본 제공 숫자 형식과 열거형/구조체(사용자 정의 포함)등으로 구성된다.
- 참조 형식은 string 및 인터페이스/클래스(사용자 정의 포함)등으로 구성된다.

### 값 형식
- 값 형식의 종류
  * 모든 기본 제공 숫자 형식(int, float, double ...)
  * boolean 형식
  * 열거형
  * 구조체(사용자 정의 포함)
- 값 형식의 경우 인수를 통해 메서드에 전달될때, 참조 형식과는 다르게 해당 형식의 인스턴스가 복사된다.
- 값 형식이 참조 형식의 데이터 구성원을 포함하는 경우 값 형식의 인스턴스가 복사될때 참조형식의 인스턴스에 대한 참조만 복사된다.

### 참조 형식
- 참조 형식의 종류
  * 클래스
  * 인터페이스
  * 대리자
  * 배열
  * 문자열
- 참조 형식은 참조 카운트 형식으로 인스턴스 메모리를 관리
- 참조 형식은 인루를 통해 메서드에 전달될때, 인스턴스의 참조 주소가 전달
- 모든 배열은 해당 요소가 값 형식이더라도 참조 형식이다

</br>
</br>

## Boxing 과 Unboxing

### Boxing
- 값 형식을 참조 형식으로 변환하는 프로세스
- 값 형식을 Boxing 변환 하면 힙에 개체 인스턴스(object 형식)가 할당되고 값이 새로 할당된 인스턴스에 복사된다.

### Unboxing
- 참조 형식을 값 형식으로 변환하는 프로세스
- Unboxing 연산과정
    * 개체 인스턴스가 지정한 값 형식을 Boxing한 값인지 확인
    * 인스턴스의 값을 값 형식 변수에 복사
- 런타임에 값 형식의 Unboxing이 성공하려면 Unboxing되는 항목은 이전에 해당 값 형식의 인스턴스를 Boxing하여 생성된 개체에 대한 참조여야된다.
- null을 Unboxing 할 경우 NullReferenceException이 발생, 호환 되지 않는 값 형식에 대한 참조를 Unboxing 하는 경우 InvalidCastException이 발생 된다.
 
</br>
</br>

## 제네릭
- 코드의 재사용성, 형식 안정성 및 성능을 최대화 가능
- c++의 템플릿과 유사하지만 기능은 템플릿 처럼 유연하지 않음
- 제네릭은 런타임에 타입이 확정되지만 템플릿의 경우 컴파일 타임에 타입이 세팅
- 템플릿의 경우 명시적 특수화, 부분 특수화를 지원하지만 제네릭의 경우 지원하지 않는다.

## 리플렉션
- 런타임 시점에 사용되는 자신의 구조화 행위를 관리하고 수정할 수 있는 프로세스
- 런타임에 객체의 형을 결정 할 수 있는 능력
- c++ 경우 RTTI로 부분적으로 리플렉션을 처리


## JIT(Just in Time) 컴파일
- 바이트 코드(중간언어IL)를 읽어 실시간으로 기계어로 컴파일 
- 실시간으로 처리 되어 AOT 보다 느림.
- 안드로이드의 경우도 JIT으로 처리되었지만 4~5에서 AOT 컴파일로 변경.

## AOT(Ahead of Time) 컴파일
- 바이트 코드(중간언어IL)을 특정 시점에 미리 컴파일.
- 대표적인 IOS

## 가비지 컬렉션(GC)

### c/c++에서의 메모리 관리
c/c++은 메모리 할당/해제는 프로그래머의 역활이다. 할당은 new 연산자/ malloc 함수를 이용하여 할당하고 해제의 경우는 delete 연산자 / free 함수를 통해 메모리를 해제 한다.
하지만 어떻게 c/c++로 작성된 응용 프로그램(런타임 라이브러리)은 힙(Unmanaged heap)의 메모리가 사용되고 있는지, 아닌지는 어떻게 판별하고 있을까?
방식은 Free Memory Bolock List라는 할당 가능한 메모리 블럭을 리스트를 응용 프로그램이 관리하다가 할당 요청이 있는 경우, 
메모리 블록 리스트를 검색하여 적절한 크기의 메모리 블록을 찾아 해당 메모리에 할당한다. 반대로 해제 요청이 된 경우 해제된 메모리를 다시 리스트에 삽입하는 작업을 거친다.
이렇듯 c/c++의 메모리 할당/해제는 상당한 시간과 비용이 드는 작업이다. 
특히나 반복적인 메모리 할당/해제가 발생될 경우 메모리가 조각나 흔히 말하는 메모리 파편화가 발생되어 적절한 크기의 메모리를 찾는데 많은 오버헤드를 발생시킨다.

### .Net의 메모리 관리
c/c++과는 반대로 닷넷 환경의 GC는 선형 메모리 할당과 사용되지 않는 메모리를 찾아 제거 하는 형태로 이루어 진다.
선형 메모리 할당은 c/c++ 처럼 자유 메모리 블럭 리스트로 메모리를 관리하는것이 아니라, 메모리 할당을 위한 포인터(NextObjPtr)만 유지하는 방식이다.
메모리 할당 요청이 있는 경우 해당 포인터를 할당 크기만큼 증가 시키고, 해제의 경우 할당한 메모리를 0으로 초기화 시키는 방식이다.
GC의 메모리 할당은 c/c++ 비교해 메모리 블럭을 검사할 필요가 없이 단순히 포인터 값을 증가시키는게 끝이므로 매우 빠르고, 메모리 파편화가 거의 일어나지 않는다.
GC의 메모리 해제는 현재 수행중인 쓰레드를 모두 중단시키고 GC 쓰레드를 활성화 시켜 사용하지 않는 객체들을 제거한다. 사용하지 않는 객체를 판단하는 기준은 GC가 생성하는 객체 참조 그래프를 이용한다.
객체 잠조 그래프는 루트 참조(스레드의 로컬 변수(스택 변수), cpu 레지스터 변수가 가지는 참조, 현재사용되는 타입(클래스)의 정적 필드 및 정적 변수등)를 참조하는 모든 객체를 그래프에 추가하여 그래프를 만든다.
그리고 해당 그래프에 포함되지 않는 객체는 가비지 컬렉션의 대상이 된다.


### 세대별 가비지 컬렉션
- 관리되는 힙(Managaed heap)상의 객체를 객체 생존 시간에 따라 세대로 구분하여 가비지 컬렉션을 수행하는 방법
- 최대 2세대(0, 1, 2)까지 구분 되며 각 세대별 가비지 컬렉션의 수행이 다르게 이뤄진다.
- 가장 많이 가비지 컬렉션이 수행되는 세대는 0세대
  * 최근 생성된 객체일수록 생명 주기는 짧다.(작은 객체일수록 생성된 후 짧은 시간 동안 사용되고 더 이상 사용되지 않는다.)
  * 오래된 객체일수록 생명 주기는 짧다.
  * 최근에 생성된 객체들끼는 서로 연관성이 높으며(참조 관계) 비슷한 시점에서 액세스 된다.
  * 일부분의 힘을 가비지 컬렉션 하는 것은 전체를 가비지 컬렉션 하는 것보다 빠르다.
- 0세대 가비지 컬렉션에서 생존한 객체들은 1세대로 승급되며 마찬가지로 1세대 가비지 컬렉션에서 생존된 객체는 2세대로 승급된다.

### Large Object Heap(LOH)
- CLR(공통 언어 런타임)은 크게 2부분으로 나눠서 관리하는데 SOH(Small Object Heap)과 LOH.
- 85000 바이트 이상 상대적으로 커다란 객체가 할당되는 힙(SOH는 세대로 관리되는 메모리 힙을 말하며 85000 바이트 이하의 객체가 할당되는 힙)(배열)
- LOH는 c/c++ 메모리 할당과 유사하게 할당 가능한 크기의 메모리가 있는지 검사하여 메모리를 할당하고 가비지 컬렉션 시 해당 메모리를 제거만 하고 빈공간을 늘리는 Compaction 작업은 하지 않는다.
- LOH는 SOH와는 다르게 메모리 파편화가 자주 발생한다.

### 가비지 컬렉션 발생 시기
- 메모리 할당 임계치를 넘어 섰을 때
- GC.Collect()를 명시적으로 호출 했을 때
- 시스템이 메모리 부족 현상을 겪고 있을 때

