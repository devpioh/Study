# Direct3D 12 기본 지식

## 기본 지식
### 1. COM(Component Object Model)
 + DirectX에서 프로그래밍 언어 독립성과 하위 호환성을 위해 사용한 기술 (COM 기술은 1993년도 발표.)
 + 참조 카운트를 이용한 메모리 관리.
 + 모든 COM 인터페이스는 IUnKnown 인터페이스를 상속.
 + COM 인터페이스들은 이름이 'I'로 시작한다.(ex : ID3DDevice)
 + DirectX COM 객체는 메모리를 new 할당 하지 않고 반드시 객체 생성 API로 할당.
 + COM 객체에 대한 인터페이스 포인터를 다른 변수로 복사할때는 AddRef() 호출.
 + COM 객체에 대한 인터페이스 포인터가 필요 없거나 제거시 Release() 호출. 
 + COM 객체를 좀 더 효율적으로 관리하기 위한 ComPtr 클래스 제공.
 + ComPtr 클래스는 스마트 포인터와 같이 자동으로 COM 객체의 참조 카운트를 확인하여 자동으로 Release() 호출.
<br>
<br>

### 2. 텍스처 형식
 + 2차원 텍스처는 자료 원소들의 2차원 배열.
 + 2차원 텍스처는 2차원 이미지를 저장하는데, 텍스처의 각 원소는 이미지 픽셀 색상 정보를 담는다.
 + 텍스쳐는 이미지 정보만이 아니라 좀 더 범용적으로 사용.
 + DirectX 12에서는 텍스처에 담을수 있는 형식을 DXGI_FORMAT 열거형으로 정의.
   - 열거형 형식의 이름은 아래와 같은 규칙
     ```
     _FLOAT : 실수
     _SINT : 2의 보수, 부호화 정수
     _UINT : 부호화 되지 않는 정수
     _SNORM : 부호화 정수, 셰이더에서는 정규화된 실수 [-1.0, 1.0]
     _SRGB : 표준 RGB
     _TYPELESS : 무형식 리소스
     _UNORM : 부호화 되지 않은 정수, 셰이더에서는 정규화된 실수 [0.0, 1.0]
     
     R : Red
     G : Green
     B : Blue
     A : Alpha
     D : Depth
     S : Stencil
     X : Don't Care
     BC : Block Compression
     ```
 + _TYPELESS 형식의 텍스처의 경우, 일단 메모리만 확보해두고 구체적인 해석은 파이프라인에 묶을 때 지정하는 용도
<br>
<br>

### 3. 교환 사슬(SwapChain)
 + 하나의 버퍼만을 이용해 렌더링을 한다고 가정해보자.
   - 다음 프레임을 렌더링 하기 위해 현재 버퍼를 비우거나 덮어쓰는 작업을 하게 된다.
   - 이때 모니터에서는 버퍼를 비우는 경우 화면이 깜빡이는 현상(Flickering)이 나타나거나, 버퍼를 덮어쓰는 경우 현재 프레임과 다음 프레임이 겹치는 현상(Tearing)이 생기게 된다.
 + 깜빡임과 겹쳐지는 현상을 해결하는 방법은 간단한데, 현재 프레임과 다음 프레임의 버퍼를 각각 두고 교체하는 것이다.
 + 현재 프레임이 그려지는 버퍼를 전면 버퍼(Front Buffer), 다음 프레임이 그려지는 버퍼를 후면 버퍼(Back buffer)라고 한다.
 + DirectX에서는 후면 버퍼와 전면 버퍼를 교체하여 다음 프레임으로 전환 되게 하는것을 프레젠팅(Presenting)이라 하는데, 전환 시 버퍼의 내용을 바꾸는게 아니라 전면/후면 버퍼의 포인터만을 교체 하여 처리한다.
   - 버퍼 포인터를 교체하는것을 플리핑(Flipping)이라 하는데, 이 작업은 하드웨어 적으로 이러지므로 매우 빠르다.
 + 이렇게 버퍼를 2개를 가지고 렌더링을 하는 기법을 더블 버퍼링(Double Buffering) 이라고 한다.
 + 후면 버퍼의 경우 필요 시 추가적으로 더 생성이 가능하다.
 + 플리핑을 위해 DirectX는 전면 버퍼와 후면 버퍼 사이가 마치 사슬을 형성하듯이 구성, 이를 교환 사슬(SwapChain)이라 한다.
 + 교환 사슬은 즉, 연속된 프레임 버퍼들의 집합으로 표현될 수 있다.
<br>
<br>

### 4. 깊이 버퍼(depth buffer)
 + 깊이 버퍼는 텍스처가 범용적으로 사용되는 예 중 하나.
 + 깊이 버퍼는 각 픽셀의 깊이 정보를 가지는데 0.0 ~ 1.0 사이의 값.
 + 시야 절두체(View Frustom)안에서 가장 가까운 물체는 0.0, 가장 먼 물체는 1.0 으로 정의 된다.
 + 깊이 버퍼의 원소는 후면 버퍼의 픽셀과 1:1로 대응.
   - 후면 버퍼 해상도가 1280X1024일 경우, 깊이 버퍼 원소 개수도 1280X1024개
 + DirectX에서는 물체의 원근을 판별 하기위해 깊이 버퍼링 or Z-버퍼링 기법 사용.
 + 깊이 버퍼링은 하드웨어에서 무료로 처리됨.
<br>
<br>

### 5. 자원(Resource)과 서술자(Descriptor)
 + 자원(Resource) 혹은 GPU 자원이란, 버퍼/텍스처/셰이더 자원 등이다.
   - GPU에서 사용하는 범용적인 메모리 조각으로 볼 수도 있다.
 + 자원은 앞서 설명했듯이 범용적인 메모리 조각들인데 이는 렌더링 파이프라인의 서로 다른 단계(Stage)에서 사용이 가능.
 + 자원 자체는 자신이 렌더 대상으로 쓰이는지, 아니면 깊이/스텐실 버퍼나 셰이더 자원으로 쓰이는지에 대해 알 수 없다.
 + 자원의 일부영역만 렌더링 파이프라인에 묶고 싶은데, 자원에는 이런 부분 영역에 대한 정보가 없다.
 + 위와 같이 자원에 대한 정보를 서술하는게 서술자(Descriptor) 객체이다.
 + GPU는 그리기 호출(draw call)을 실행 시 직접적으로 자원을 참조하지 않고, 서술자 객체를 통해 자원을 참조한다.
   - 그리기 호출이 참조할 GPU 자원들을 렌더링 파이프라인과 연결하는 작업을 바인딩(binding)이라고 한다.
 + 서술자의 종류
   - CBV / SRV / UAV 서술자들은 각각 상수 버퍼(contant buffer), 셰이더 자원(shader resource), 순서 없는 접근 (unordered access view)를 서술.
   - 표본추출기(Sampler) 서술자는 텍스처 적용에 쓰이는 표본추출기 자원을 서술.
   - RTV 서술자는 렌더 대상(Render target) 자원을 서술.
   - DSV 서술자는 깊이/스텐실(Depth/Stencil) 자원을 서술.
 + 서술자 힙(decrtiptor heap)은 응용프로그램이 사용하는 서술자들이 저장되는 힙.
 + 서술자의 종류마다 개별적인 서술자 힙이 필요.
 + 한 종류의 서술자에 대해 여러 개의 힙을 둘 수 있다.
 + 하나의 자원을 참조하는 서술자가 하나뿐이여야만 하는 것은 아님, 여러 서술자가 하나의 자원을 참조 할 수 있다.
 + 하나의 자원을 렌더링 파이프라인의 여러단계에 묶을 수 있는데, 이때 단계마다 개별적인 서술자가 필요.
<br>
<br>

### 6. 다중표본화(multi-sampling)
 + 모니터에서 임의의 선을 그릴경우 계단처럼 나타나는 경우가 있는데 이를 앨리어싱(Aliasing) 효과라고 한다.
   - 현재 모니터의에서 이 계단 현상(앨리어싱)을 완벽하게 제거하는 방법은 불가능하다.
   - 계단 현상을 완화 하는 기술이 있는데 이를 안티 앨리어싱(Anti-Aliasing)이라고 한다.
 + 안티 앨리어싱은 픽셀을 표본화 함수(sampling function)를 통해 픽셀 평균 색값으로 경계를 처리.
 + 안티 앨리어싱은 많은 기법들이 있지만, 그 중 2가지 기법을 알아본다.
   1. FSAA(Full-Scene Anti-Aliasing) or SSAA(Super-Sampliing Anti-Aliasing)
      - 후면 버퍼의 해상도를 4배로 늘린 후 렌더링 한 다음 다시 원래 해상도로 되돌리는 처리(다운 샘플링:DownSampling)를 통해 앨리어싱 현상을 줄이는 방법
      - 모든 안티 앨리어싱 기법중 가장 확실하게 앨리어싱 현상을 줄이지만 연산량이 4배로 들어 비용이 많이 든다.
   2. MSAA(Multi-Sampliing Aliasing)
      - SSAA의 많은 연산량과 비용을 드는 문제를 개량한 방법.
      - SSAA와는 다르게 모든 부분 픽셀을 계산하지 않고 한번 만 계산 후 해당 평균 픽셀 값을 부분 픽셀들이 공유하여 사용.
      - 서브 픽셀 배치되는 지점은 하드웨어에 따라 따라 다르므로 Direct3D는 구체적으로 명시하지 않는다.
 + Direct3D에서는 모든 DXGI형식에 대한 4X 멀티 샘플링(다중표본화)를 지원한다.
   - 멀티 샘플링의 경우 연산이 많이 드는 작업이므로 하드웨어 적으로 처리가 필요.
<br>
<br>

### 7. 기능 수준(feature level)
 + 기능 수준이란 개념은 Direct11에서 도입된 것으로 코드에서는 D3D_FEATURE_LEVEL 이라는 열거형으로 대표된다.
 ```c++
 enum D3D_FEATURE_LEVEL
 {
     D3D_FEATURE_LEVEL_9_1      = 0x9100,
     D3D_FEATURE_LEVEL_9_2      = 0x9100,
     D3D_FEATURE_LEVEL_9_3      = 0x9100,
     D3D_FEATURE_LEVEL_10_0     = 0x9100,
     D3D_FEATURE_LEVEL_10_1     = 0x9100,
     D3D_FEATURE_LEVEL_11_0     = 0x9100,
     D3D_FEATURE_LEVEL_11_1     = 0x9100,
 } D3D_FEATURE_LEVEL;
 ```
 + 기능수준은 GPU가 지원하는 기능들의 엄격한 집합을 정의. 
   - 예를 들면 기능수준 11을 지원하는 GPU는 반드시 Direct11의 기능 전체를 지원.
   - 현재 GPU의 기능 수준을 파악하기만 하면, 구체적으로 어떤 기능을 사용할 수 있는지를 확실히 알 수 있기 때문.
   - 사용자의 하드웨어가 특정 기능 수준을 지원하지 않는 경우 응용프로그램의 샐행을 아에 포기하는 대신 더 낮은 기능 수준으로 후퇴 하는 전략을 사용 가능.
<br>
<br>

### 8. DXGI(DirectX Graphics Infrastructure)
 + Direct3D와 함께쓰이는 API로 그래픽 런타임에 독립적인 저수준(Low-Level)작업을 관리.
   - 커널모드 드라이버/하드웨어 단계의 기능 처리.
 + 여러 그래픽 API의 공통적인 그래픽 기능성 작업 모음(교환 사슬의 생성, 프레젠테이션, GPU 어뎁터 열거등)
 + 실제 3D 그래픽스를 구현하는 기능과는 별개로 독립적으로 이루어지는 기능들을 분리.
<br>
<br>

### 9. 상주성(residency)
 + Direct12에서 응용프로그램은 자원을 GPU 메모리에서 올리거나 내리는 상주성 관리가 중요.
 + 성능 측면에서 한가지 주의점은 같은 자원을 짧은 시간에 GPU 메모리에 올렸다 내렸다 하는 상황을 피하는것이 중요.
 + Direct12는 응용프로그램이 GPU 메모리 상주성을 제어 가능.
   - HRESULT ID3D12Device::MakeResident( UINT NumObjects, ID3D12Pageable *const *ppObjects);
   - HRESULT ID3D12Device::Evict( UINT NumObjects, ID3D12Pageable *const *ppObjects );
   
<br>
<br>

  